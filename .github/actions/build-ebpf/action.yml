name: 'Build eBPF Programs'
description: 'Compile eBPF programs using libbpf headers matching tinybpf'
author: 'gregclermont'

branding:
  icon: 'cpu'
  color: 'orange'

inputs:
  sources:
    description: 'Glob pattern for .bpf.c source files'
    required: false
    default: '**/*.bpf.c'
  output-dir:
    description: 'Output directory for .bpf.o files (empty = same as source)'
    required: false
    default: ''
  libbpf-version:
    description: 'libbpf version (reads .libbpf-version if empty)'
    required: false
    default: ''
  vmlinux-h:
    description: 'Custom vmlinux.h path (downloads pre-generated if empty)'
    required: false
    default: ''
  arch:
    description: 'Target arch: x86_64 or aarch64 (auto-detect if empty)'
    required: false
    default: ''
  extra-cflags:
    description: 'Additional clang flags'
    required: false
    default: ''

outputs:
  object-files:
    description: 'Compiled .bpf.o files (space-separated)'
    value: ${{ steps.compile.outputs.object-files }}
  libbpf-headers-path:
    description: 'Path to libbpf headers'
    value: ${{ steps.setup-headers.outputs.libbpf-path }}
  vmlinux-h-path:
    description: 'Path to vmlinux.h'
    value: ${{ steps.setup-vmlinux.outputs.vmlinux-path }}

runs:
  using: 'composite'
  steps:
    - name: Detect architecture
      id: detect-arch
      shell: bash
      run: |
        if [ -n "${{ inputs.arch }}" ]; then
          ARCH="${{ inputs.arch }}"
        else
          case "$(uname -m)" in
            x86_64) ARCH="x86_64" ;;
            aarch64) ARCH="aarch64" ;;
            *) echo "::error::Unsupported architecture: $(uname -m)"; exit 1 ;;
          esac
        fi
        echo "arch=$ARCH" >> $GITHUB_OUTPUT

        # Map to vmlinux.h directory names
        case "$ARCH" in
          x86_64) VMLINUX_ARCH="x86" ;;
          aarch64) VMLINUX_ARCH="aarch64" ;;
        esac
        echo "vmlinux-arch=$VMLINUX_ARCH" >> $GITHUB_OUTPUT

    - name: Determine libbpf version
      id: libbpf-version
      shell: bash
      run: |
        if [ -n "${{ inputs.libbpf-version }}" ]; then
          VERSION="${{ inputs.libbpf-version }}"
        elif [ -f ".libbpf-version" ]; then
          VERSION=$(cat .libbpf-version | tr -d '[:space:]')
        else
          echo "::error::libbpf-version not specified and .libbpf-version not found"
          exit 1
        fi
        echo "version=$VERSION" >> $GITHUB_OUTPUT

    - name: Verify clang BPF target
      shell: bash
      run: |
        if ! command -v clang &> /dev/null; then
          echo "::error::clang not found"
          exit 1
        fi
        if ! clang --print-targets 2>/dev/null | grep -q "bpf"; then
          echo "::error::clang does not support BPF target"
          exit 1
        fi
        echo "Using clang $(clang --version | head -1)"

    - name: Download libbpf headers
      id: setup-headers
      shell: bash
      run: |
        VERSION="${{ steps.libbpf-version.outputs.version }}"
        HEADERS_DIR="${{ runner.temp }}/libbpf-headers"
        mkdir -p "$HEADERS_DIR/bpf"

        echo "Downloading libbpf v$VERSION headers..."
        curl -sL "https://github.com/libbpf/libbpf/archive/refs/tags/v${VERSION}.tar.gz" | \
          tar xz -C "$HEADERS_DIR/bpf" --strip-components=2 "libbpf-${VERSION}/src"

        echo "libbpf-path=$HEADERS_DIR" >> $GITHUB_OUTPUT

    - name: Setup vmlinux.h
      id: setup-vmlinux
      shell: bash
      run: |
        if [ -n "${{ inputs.vmlinux-h }}" ]; then
          VMLINUX_PATH="${{ inputs.vmlinux-h }}"
          if [ ! -f "$VMLINUX_PATH" ]; then
            echo "::error::Custom vmlinux.h not found: $VMLINUX_PATH"
            exit 1
          fi
        else
          VMLINUX_ARCH="${{ steps.detect-arch.outputs.vmlinux-arch }}"
          VMLINUX_DIR="${{ runner.temp }}/vmlinux"
          mkdir -p "$VMLINUX_DIR"

          echo "Downloading vmlinux.h for $VMLINUX_ARCH..."
          # Download tarball and extract the correct vmlinux.h (symlinks don't work via raw.githubusercontent)
          curl -sL "https://github.com/libbpf/vmlinux.h/archive/refs/heads/main.tar.gz" | \
            tar xz -C "$VMLINUX_DIR" --strip-components=1

          # The include/{arch}/vmlinux.h files are symlinks, resolve them
          VMLINUX_PATH=$(readlink -f "$VMLINUX_DIR/include/${VMLINUX_ARCH}/vmlinux.h")

          # Copy to a simple location
          cp "$VMLINUX_PATH" "$VMLINUX_DIR/vmlinux.h"
          VMLINUX_PATH="$VMLINUX_DIR/vmlinux.h"
        fi

        echo "vmlinux-path=$VMLINUX_PATH" >> $GITHUB_OUTPUT
        echo "vmlinux-dir=$(dirname $VMLINUX_PATH)" >> $GITHUB_OUTPUT

    - name: Find and compile eBPF programs
      id: compile
      shell: bash
      run: |
        LIBBPF_HEADERS="${{ steps.setup-headers.outputs.libbpf-path }}"
        VMLINUX_DIR="${{ steps.setup-vmlinux.outputs.vmlinux-dir }}"
        OUTPUT_DIR="${{ inputs.output-dir }}"
        EXTRA_CFLAGS="${{ inputs.extra-cflags }}"
        ARCH="${{ steps.detect-arch.outputs.arch }}"
        PATTERN="${{ inputs.sources }}"

        # Set target arch define
        case "$ARCH" in
          x86_64) TARGET_ARCH="x86" ;;
          aarch64) TARGET_ARCH="arm64" ;;
        esac

        CFLAGS="-g -O2 -target bpf"
        CFLAGS="$CFLAGS -D__TARGET_ARCH_${TARGET_ARCH}"
        CFLAGS="$CFLAGS -I$LIBBPF_HEADERS"
        CFLAGS="$CFLAGS -I$VMLINUX_DIR"
        CFLAGS="$CFLAGS $EXTRA_CFLAGS"

        echo "Compile flags: $CFLAGS"

        # Find source files
        shopt -s nullglob globstar
        FILES=($PATTERN)

        if [ ${#FILES[@]} -eq 0 ]; then
          echo "::error::No source files found matching: $PATTERN"
          exit 1
        fi

        echo "Found ${#FILES[@]} source file(s)"

        OBJECT_FILES=""
        FAILED=0

        for src in "${FILES[@]}"; do
          if [ -n "$OUTPUT_DIR" ]; then
            base=$(basename "$src" .bpf.c)
            obj="$OUTPUT_DIR/${base}.bpf.o"
            mkdir -p "$OUTPUT_DIR"
          else
            obj="${src%.bpf.c}.bpf.o"
          fi

          echo "Compiling $src -> $obj"
          if clang $CFLAGS -c "$src" -o "$obj"; then
            OBJECT_FILES="$OBJECT_FILES $obj"
          else
            echo "::error file=$src::Compilation failed"
            FAILED=1
          fi
        done

        if [ $FAILED -eq 1 ]; then
          exit 1
        fi

        OBJECT_FILES="${OBJECT_FILES# }"
        echo "object-files=$OBJECT_FILES" >> $GITHUB_OUTPUT
        echo "Successfully compiled: $OBJECT_FILES"
